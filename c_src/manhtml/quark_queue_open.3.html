<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="mandoc.css" type="text/css" media="all"/>
  <title>QUARK_QUEUE_OPEN(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">QUARK_QUEUE_OPEN(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">QUARK_QUEUE_OPEN(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">quark_queue_open</code> &#x2014;
    <span class="Nd">initialize a <var class="Vt">quark_queue</var></span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
  &lt;<a class="In">quark.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">quark_queue_open</code>(<var class="Fa" style="white-space: nowrap;">struct
    quark_queue *qq</var>, <var class="Fa" style="white-space: nowrap;">int
    flags</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><code class="Nm">quark_queue_open</code> initializes the
    <var class="Vt">quark_queue</var> pointed to by
  <var class="Fa">qq</var>.</p>
<p class="Pp">A <var class="Vt">quark_queue</var> is the main runtime
    datastructure of quark, it is loosely called a queue as it's where events
    will originate from. Events will be collected into the queue, buffered,
    aggregated and filtered if necessary.</p>
<p class="Pp">The <code class="Nm">quark_queue_open</code> function does the
    following:</p>
<ul class="Bl-bullet">
  <li>Attempts to use the best backend available unless otherwise especified.
      This includes loading the EBPF programs for EBPF or the probes for
      KPROBES. Only one backend is used and it defaults to EBPF and fallsback to
      KPROBE.</li>
  <li>On its first call it will also initialize global host state, like BTF
      offsets and HZ.</li>
  <li>Initializes the various lists and internal buffers of
      <var class="Fa">qq</var>.</li>
  <li>If KPROBES is selected, it initializes one perf-ring per-cpu in order to
      collect process events, see
      <a class="Xr" href="quark_queue_get_epollfd.3.html">quark_queue_get_epollfd(3)</a>
      and
      <a class="Xr" href="quark_queue_block.3.html">quark_queue_block(3)</a>.</li>
  <li>If EBPF is selected, it initializes an EBPF ringbuffer, support for old
      style perf-rings with EBPF is currently not supported.</li>
  <li>Scrapes <span class="Pa">/proc</span> for a snapshot of the existing
      processes in the system. <code class="Nm">quark_queue_open</code> is smart
      enough to open the rings before the scraping, as to be make sure no
      process is lost. These initial process events will be available on the
      first call to
      <a class="Xr" href="quark_queue_get_events.3.html">quark_queue_get_events(3)</a>
      with the <var class="Vt">events</var> member set to
      <code class="Dv">QUARK_EV_SNAPSHOT</code>.</li>
</ul>
<p class="Pp"><var class="Fa">flags</var> is a bitmask that changes the default
    queue behaviour with the following values:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<dl class="Bl-tag Bl-compact">
  <dt id="QQ_EBPF"><a class="permalink" href="#QQ_EBPF"><code class="Dv">QQ_EBPF</code></a></dt>
  <dd>Enable the EBPF backend, in case neither <code class="Dv">QQ_EBPF</code>
      or <code class="Dv">QQ_KPROBE</code> are specified, it defaults to both.
      EBPF is attempted first and fallsback to KPROBE if it failed.</dd>
  <dt id="QQ_KPROBE"><a class="permalink" href="#QQ_KPROBE"><code class="Dv">QQ_KPROBE</code></a></dt>
  <dd>Enable the KPROBE backend, see above.</dd>
  <dt id="QQ_THREAD_EVENTS"><a class="permalink" href="#QQ_THREAD_EVENTS"><code class="Dv">QQ_THREAD_EVENTS</code></a></dt>
  <dd>Include per-thread events, instead of per-process events. This option will
      be removed in the future, but it may be useful for debugging.</dd>
  <dt id="QQ_NO_CACHE"><a class="permalink" href="#QQ_NO_CACHE"><code class="Dv">QQ_NO_CACHE</code></a></dt>
  <dd>Don't use the internal process cache to enrich events, normally when quark
      receives an event, it will include all the cached information it had about
      that process so that the event has more context, passing this flag will
      get you &quot;naked&quot; events.</dd>
</dl>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp">Zero on success, -1 otherwise and <var class="Va">errno</var> is
    set. In the case of an error, the internal state is cleared up and a
    <a class="Xr" href="quark_queue_close.3.html">quark_queue_close(3)</a>
    should NOT be issued.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="quark_event_dump.3.html">quark_event_dump(3)</a>,
    <a class="Xr" href="quark_event_lookup.3.html">quark_event_lookup(3)</a>,
    <a class="Xr" href="quark_queue_block.3.html">quark_queue_block(3)</a>,
    <a class="Xr" href="quark_queue_close.3.html">quark_queue_close(3)</a>,
    <a class="Xr" href="quark_queue_get_epollfd.3.html">quark_queue_get_epollfd(3)</a>,
    <a class="Xr" href="quark_queue_get_events.3.html">quark_queue_get_events(3)</a>,
    <a class="Xr" href="quark_queue_get_stats.3.html">quark_queue_get_stats(3)</a>,
    <a class="Xr" href="quark.7.html">quark(7)</a>,
    <a class="Xr" href="quark-btf.8.html">quark-btf(8)</a>,
    <a class="Xr" href="quark-mon.8.html">quark-mon(8)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">Multiple queues are supported, but discouraged. Opening and
    closing (but not using!) queues from different threads must be synchronized
    by the caller, this is because there is global internal state that might
    change in <code class="Nm">quark_queue_open</code> and
    <a class="Xr" href="quark_queue_close.3.html">quark_queue_close(3)</a>.
    Notably there is a single KPROBE installation shared by all queues.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">May 22, 2024</td>
    <td class="foot-os">Linux 6.8.7-200.fc39.aarch64</td>
  </tr>
</table>
</body>
</html>
