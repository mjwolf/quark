<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="mandoc.css" type="text/css" media="all"/>
  <title>QUARK(7)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">QUARK(7)</td>
    <td class="head-vol">Miscellaneous Information Manual</td>
    <td class="head-rtitle">QUARK(7)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">quark</code> &#x2014; <span class="Nd">unified
    system process telemetry library</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><code class="Nm">quark</code> is a library that provides a way to
    retrieve and listen to process events in linux systems. Its main purpose is
    to abstract different backends and to provide a common API for listening to
    system-wide events like <a class="Xr" href="fork.2.html">fork(2)</a>,
    <a class="Xr" href="exec.3.html">exec(3)</a>,
    <a class="Xr" href="exit.3.html">exit(3)</a> and others.</p>
<p class="Pp"><code class="Nm">quark</code> not only provides an API for
    listening to events, but also handles ordering, buffering and aggregation of
    said events. In its most basic form, a short lived process consisting of
    <a class="Xr" href="fork.2.html">fork(2)</a> +
    <a class="Xr" href="exec.3.html">exec(3)</a> +
    <a class="Xr" href="exit.3.html">exit(3)</a> will be aggregated into one
    <var class="Vt">quark_event</var>. An internal event cache is also kept that
    can be looked up via
    <a class="Xr" href="quark_event_lookup.3.html">quark_event_lookup(3)</a>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FEATURES"><a class="permalink" href="#FEATURES">FEATURES</a></h1>
<dl class="Bl-ohang">
  <dt id="ORDERING"><a class="permalink" href="#ORDERING"><i class="Em">ORDERING</i></a></dt>
  <dd><code class="Nm">quark</code> tries to guarantee event ordering as much as
      possible. Ordering must be done in userland for some backends, notably
      anything that uses perf-rings. <code class="Nm">quark</code> uses two
      <a class="permalink" href="#Rank"><i class="Em" id="Rank">Rank Balanced
      Trees</i></a> for ordering and aggregation.
    <p class="Pp">The first tree is basically a priority queue, ordered by the
        time of the event. The second tree is ordered by time of the event + pid
        and it's used for event aggregation.</p>
  </dd>
  <dt id="AGGREGATION"><a class="permalink" href="#AGGREGATION"><i class="Em">AGGREGATION</i></a></dt>
  <dd><code class="Nm">quark</code> buffers and aggregates related events that
      happened close enough. The common case is generating a single event for
      the triple: <a class="Xr" href="fork.2.html">fork(2)</a>,
      <a class="Xr" href="exec.3.html">exec(3)</a>,
      <a class="Xr" href="exit.3.html">exit(3)</a>. There are rules on what can
      be aggregated, and only events of the same pid are aggregated. For
      example: <code class="Nm">quark</code> won't aggregate two
      <a class="Xr" href="exec.3.html">exec(3)</a> events, otherwise we would
      lose the effects of the first one. These rules will be exposed and
      configurable in the future.</dd>
  <dt id="BUFFERING"><a class="permalink" href="#BUFFERING"><i class="Em">BUFFERING</i></a></dt>
  <dd>For aggregation and ordering to work, <code class="Nm">quark</code> needs
      to be able to buffer events, this means holding them before presenting
      them to the user. <code class="Nm">quark</code> employs an ageing timeout
      that is a stepped function of the number of currently buffered events, the
      more events you have, the shorter the timeout will be, so memory can be
      bound. A <var class="Vt">quark_event</var> is only given to the user when
      it has a certain age. From quark.c:
    <div class="Bd Pp Bd-indent Li">
    <pre>/*
 * Target age is the duration in ns of how long should we hold the event in the
 * tree before processing it. It's a function of the number of items in the tree
 * and its maximum capacity:
 * from [0; 10%]    -&gt; 1000ms
 * from [90%; 100%] -&gt; 0ms
 * from (10%; 90%)  -&gt; linear from 1000ms -&gt; 100ms
 */</pre>
    </div>
  </dd>
  <dt id="ENRICHMENT"><a class="permalink" href="#ENRICHMENT"><i class="Em">ENRICHMENT</i></a></dt>
  <dd>The library tries to give as much context for an event as possible.
      Depending on the backend, the events we read from the kernel can be
      limited in context. <code class="Nm">quark</code> maintains an internal
      process table with what has been learned about the process so far, this
      context is then included in each event given to the user. The process
      table can also be queried, see below.</dd>
  <dt id="PROCESS"><a class="permalink" href="#PROCESS"><i class="Em">PROCESS
    TABLE</i></a></dt>
  <dd>An internal cache of process events is kept that can be looked up via
      <a class="Xr" href="quark_event_lookup.3.html">quark_event_lookup(3)</a>.
      This cache keeps soon-to-be-purged elements for a little while so that you
      can still lookup a process that just exited. The table is initialized by
      scraping <span class="Pa">/proc</span>.</dd>
  <dt id="TRANSPARENCY"><a class="permalink" href="#TRANSPARENCY"><i class="Em">TRANSPARENCY</i></a></dt>
  <dd><code class="Nm">quark</code> tries to be as transparent as possible about
      what it knows, there are counters for lost events, and each piece of
      information of a <var class="Vt">quark_event</var> is guarded by a flag,
      meaning the user might get incomplete events in the case of lost events,
      it's the user responsability to decide what to do with it.
    <p class="Pp">Depending on load, the user might see an event as the
        aggregation of multiple events, or as independent events. The content
        remains the same.</p>
  </dd>
  <dt id="LANGUAGE"><a class="permalink" href="#LANGUAGE"><i class="Em">LANGUAGE
    BINDINGS</i></a></dt>
  <dd><code class="Nm">quark</code> is written in C, but Go bindings are also
      provided. Ideally we will be able to provide bindings for other languages
      in the future.</dd>
  <dt id="MULTIPLE"><a class="permalink" href="#MULTIPLE"><i class="Em">MULTIPLE
    BACKENDS</i></a></dt>
  <dd>Currently, EBPF and a kprobe-based backend are provided, but we would like
      to add AUDIT support as well. The backend in use is transparent to the
      user and unless specified, <code class="Nm">quark</code> will try to use
      the EBPF, falling back to KPROBE if it failed.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUILDING"><a class="permalink" href="#BUILDING">BUILDING</a></h1>
<p class="Pp"><a class="permalink" href="#make"><i class="Em" id="make">make</i></a>
    generates a <span class="Pa">libquark.a</span> that can be linked with the
    user binary, be sure to clone the repository with
    <a class="permalink" href="#git"><i class="Em" id="git">git clone
    --recursive</i></a>.</p>
<p class="Pp" id="libbpf"><code class="Nm">quark</code> builds its own
    <a class="permalink" href="#libbpf"><i class="Em">libbpf</i></a> since it
    needs BTF support from it. At the time of this writing,
    <span class="Pa">libquark.a</span> also needs symbols from
    <a class="permalink" href="#libz"><i class="Em" id="libz">libz</i></a> and
    <a class="permalink" href="#libelf"><i class="Em" id="libelf">libelf</i></a>.
    An option will be given in the future to include both in the archive.</p>
<p class="Pp">While <code class="Nm">quark</code> doesn't build
    <i class="Em">elastic/ebpf</i>, it does use the EBPF programs from that
    repository, only the files needed are included in
    <code class="Nm">quark</code>, as <i class="Em">elastic/ebpf</i> is quite
    big.</p>
<p class="Pp">Other useful build targets include:</p>
<dl class="Bl-tag">
  <dt id="doc"><a class="permalink" href="#doc"><i class="Em">doc</i></a></dt>
  <dd>Shorthand for manlint+manhtml+README.md, see below.</dd>
  <dt id="manlint"><a class="permalink" href="#manlint"><i class="Em">manlint</i></a></dt>
  <dd>Calls the linter for all manpages.</dd>
  <dt id="manhtml"><a class="permalink" href="#manhtml"><i class="Em">manhtml</i></a></dt>
  <dd>Generates HTML files for the manpges in manhtml/.</dd>
  <dt id="svg"><a class="permalink" href="#svg"><i class="Em">svg</i></a></dt>
  <dd>Builds an SVG out of the DOT files produced by
      <a class="Xr" href="quark-mon.8.html">quark-mon(8)</a>.</dd>
  <dt id="README.md"><a class="permalink" href="#README.md"><i class="Em">README.md</i></a></dt>
  <dd>Generates <span class="Pa">README.md</span> out of
      <span class="Pa">quark.7</span>.</dd>
  <dt id="eebpf-sync"><a class="permalink" href="#eebpf-sync"><i class="Em">eebpf-sync</i></a></dt>
  <dd>Copies the files from EEBPF_PATH used by <code class="Nm">quark</code>.
      Usage:
    <div class="Bd Pp Li">
    <pre>make eebpf-sync EEBPF_PATH=/my/path/to/elastic/ebpf</pre>
    </div>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LINKING"><a class="permalink" href="#LINKING">LINKING</a></h1>
<div class="Bd Li">
<pre>cc -o myprogram myprogram.c -lelf -lz libquark.a libbpf/src/libbpf.a</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="INCLUDED_BINARIES"><a class="permalink" href="#INCLUDED_BINARIES">INCLUDED
  BINARIES</a></h1>
<p class="Pp"><a class="Xr" href="quark-mon.8.html">quark-mon(8)</a> is a
    program that dumps <var class="Vt">quark_events</var> to stdout and can be
    used for demo and debugging. It has a neat feature: can be run without
    priviledges, while useless in this small program, it aims to demonstrate how
    a user could implement the same.</p>
<p class="Pp"><a class="Xr" href="quark-btf.8.html">quark-btf(8)</a> is a
    program for dumping BTF information used by
  <code class="Nm">quark</code>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONVENTIONS"><a class="permalink" href="#CONVENTIONS">CONVENTIONS</a></h1>
<ul class="Bl-bullet">
  <li>Library calls fail with -1 unless otherwise stated, and
      <var class="Va">errno</var> is set.</li>
  <li>No pointers to internal state are returned, data is allocated by the
      caller and the library copies out.</li>
  <li>No threads are created, the library is driven solely through
      <a class="Xr" href="quark_queue_get_events.3.html">quark_queue_get_events(3)</a>.</li>
  <li>Access to a <var class="Vt">quark_queue</var> must be synchronized by the
      user in the case of multithreading.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="BASIC_USAGE"><a class="permalink" href="#BASIC_USAGE">BASIC
  USAGE</a></h1>
<p class="Pp">The ball starts with
    <a class="Xr" href="quark_queue_open.3.html">quark_queue_open(3)</a>.</p>
<p class="Pp"><a class="Xr" href="quark_queue_open.3.html">quark_queue_open(3)</a>
    initializes a <var class="Vt">quark_queue</var> which holds the majority of
    runtime state used by library, this includes perf-rings, file descriptors,
    EBPF programs buffering data-structures and the like. It must be paired with
    a <a class="Xr" href="quark_queue_close.3.html">quark_queue_close(3)</a> on
    exit.</p>
<p class="Pp"><a class="Xr" href="quark_queue_get_events.3.html">quark_queue_get_events(3)</a>
    is the main driver of the library, it does the buffering, per-ring scanning,
    aggregation and event cache garbage collecting. In case there are no events
    it returns zero and the user is expected to call
    <a class="Xr" href="quark_queue_block.3.html">quark_queue_block(3)</a> or
    equivalent.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<div class="Bd Bd-indent Li">
<pre>#include &lt;err.h&gt;
#include &lt;quark.h&gt;
#include &lt;stdio.h&gt;

int
main(void)
{
	struct quark_queue	qq;
	struct quark_event	qevs[32], *qev;
	int			n, i;

	if (quark_queue_open(&amp;qq, 0) == -1)
		err(1, &quot;quark_queue_open&quot;);

	for (; ;) {
		n = quark_queue_get_events(&amp;qq, qevs, 32);
		if (n == -1) {
			warn(&quot;quark_queue_get_events&quot;);
			break;
		}
		/* Scan each event */
		for (i = 0, qev = qevs; i &lt; n; i++, qev++)
			quark_event_dump(qev, stdout);
		if (n == 0)
			quark_queue_block(&amp;qq);
	}

	quark_queue_close(&amp;qq);

	return (1);
}</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_READING"><a class="permalink" href="#FURTHER_READING">FURTHER
  READING</a></h1>
<p class="Pp"><a class="Xr" href="quark_queue_get_events.3.html">quark_queue_get_events(3)</a>
    is the meat of the library and contains further useful documentation.</p>
<p class="Pp"><a class="Xr" href="quark-mon.8.html">quark-mon(8)</a> is the
    easiest way to get started with <code class="Nm">quark</code>.</p>
<p class="Pp"><a class="Xr" href="quark_queue_open.3.html">quark_queue_open(3)</a>
    describes initialization options that can be useful.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="quark_event_dump.3.html">quark_event_dump(3)</a>,
    <a class="Xr" href="quark_event_lookup.3.html">quark_event_lookup(3)</a>,
    <a class="Xr" href="quark_queue_block.3.html">quark_queue_block(3)</a>,
    <a class="Xr" href="quark_queue_close.3.html">quark_queue_close(3)</a>,
    <a class="Xr" href="quark_queue_get_epollfd.3.html">quark_queue_get_epollfd(3)</a>,
    <a class="Xr" href="quark_queue_get_events.3.html">quark_queue_get_events(3)</a>,
    <a class="Xr" href="quark_queue_get_stats.3.html">quark_queue_get_stats(3)</a>,
    <a class="Xr" href="quark_queue_open.3.html">quark_queue_open(3)</a>,
    <a class="Xr" href="quark-btf.8.html">quark-btf(8)</a>,
    <a class="Xr" href="quark-mon.8.html">quark-mon(8)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp"><code class="Nm">quark</code> started in April 2024.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">May 22, 2024</td>
    <td class="foot-os">Linux 6.8.7-200.fc39.aarch64</td>
  </tr>
</table>
</body>
</html>
